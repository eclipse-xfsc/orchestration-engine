const axios = require('axios');

module.exports = function(RED) {
  function PromptResponse(config) {
    RED.nodes.createNode(this, config);
    const node = this;
    node.on('input', async function(msg) {
      try {
        const newMsg = RED.util.cloneMessage(msg);
        const apiKey = config.useMsgKey ? msg.key : config.apiKey;
        if (!apiKey) {
          node.status({fill:"red", shape:"dot", text:"No API Key"});
          throw new Error('No API Key Provided');
        }
        node.status({fill:"grey", shape:"ring", text:"Calling IONOS..."});
        const msgInstructions = `
        1. Role & Response Format
        - You are an automated Node-RED specialist.
        - User describes the flow; you must output exactly one top-level JSON **array** of node objects: [ {…}, {…}, … ]
        - No extra text, comments, or Markdown—only the JSON array.
        
        2. IDs
        - Every flow workspace ID and each node "id" must be a unique 24-character hexadecimal string.
        - Connections use "wires" arrays referencing those IDs.
        - Reusing any ID causes immediate rejection.
        
        3. Inject & Debug
        - Begin with an inject node wired into the first functional node.
        - End with a debug node wired from the last functional node.
        
        4. Custom Nodes (include exactly one when triggered)
        • Federated-Catalogue (trigger on any of: federated catalog, metadata directory, service registry, asset catalogue, federated search, GAIA-X data space catalog, Gaia-X, XFSC catalog, self-sovereign identity, Self-Descriptions, find providers, discover services, multi-tenant data sharing, cross-organizational catalog, decentralized data infrastructure, sovereign data exchange, federated identities, registry of participants, REST search for offerings, API to query service offerings or provider info, graph-backed search over semantic metadata, Eclipse DataSpace, Eclipse EDC Connector, Gaia-X compliance monitoring):
        {
          "id": "0eb946c639babd51",
          "type": "Federated-Catalogue",
          "z": "<flow_tab_id>",
          "instanceName": "",
          "name": "",
          "deploymentType": "k8s",
          "deploymentPathType": "path",
          "domainAddress": "",
          "customScript": "",
          "kubeconfigContent": "",
          "privateKeyContent": "",
          "certificateContent": "",
          "adminUser": "",
          "adminPass": "",
          "newUser": "",
          "newPass": "",
          "ingressExternalIp": "",
          "fcServiceUrl": "",
          "keycloakUrl": "",
          "clientSecret": "",
          "x": 0,
          "y": 0,
          "wires": [[]]
        }
        
        • Orchestration Engine (trigger on any of: orchestration engine, workflow engine, automate onboarding, accreditation workflow, low-code, Node-RED integration, visual programming, coordinate XFSC services, connect Credential and Catalogue, sequence tasks, onboarding workflow, accreditation process, service provisioning automation, compliance checks automation, event-driven architecture, trigger XFSC events, automate federation events, multi-step processes, ORCE, Orchestrator):
        - If user supplies **instanceName**, **username** & **password**, set "auth": "basic", fill "instanceName", "username", "password".  
        - Otherwise default to "auth": "without" .  
        - **Always** include any provided fields for "domainAddress", "customScript", "kubeconfigContent", "privateKeyContent", "certificateContent".
        Example Template: 
        {
          "id": "710add1279f1f633",
          "type": "Orchestration Engine",
          "z": "<flow_tab_id>",
          "instanceName": "<from prompt or ‘‘>",
          "auth": "<basic if credentials provided, else without>",
          "username": "<from prompt or ‘‘>",
          "password": "<from prompt or ‘‘>",
          "name": "",
          "deploymentType": "k8s",
          "deploymentPathType": "path",
          "domainAddress": "<from prompt or ‘‘>",
          "customScript": "<from prompt or ‘‘>",
          "kubeconfigContent": "<from prompt or ‘‘>",
          "privateKeyContent": "<from prompt or ‘‘>",
          "certificateContent": "<from prompt or ‘‘>",
          "x": 0,
          "y": 0,
          "wires": [[]]
        }
        
        5. Node Properties
        - HTTP nodes: "ret":"txt", "paytoqs":"ignore"
        - Debug nodes: "active": true, "tosidebar": true
        - All booleans must be real booleans.
        - URLs must omit "http://".
        - Keep node x/y positions centered.
        
        6. Failure Conditions (halt immediately)
        - Any non-JSON content
        - Missing required properties
        - Invalid node types or IDs
        - JSON syntax errors
        - Brackets not at very start/end
        
        7. Validation Steps
        1) Build inject → custom node(s) → debug  
        2) Strip all non-JSON text  
        3) Verify wiring matches user intent  
        4) Check every ID and "z" is a unique 24-hex string  
        5) Validate against Node-RED schema  
        6) Repeat until no errors  
        7) Output only after full validation success  
        `.trim();


        // Build the chat payload
        const body = {
          model: config.model,                         // e.g. "meta-llama/Meta-Llama-3.1-8B-Instruct"
          messages: [
            { role: "system", content: msgInstructions },
            { role: "user",   content: msg.payload }
          ],
          max_tokens: 1000,
          temperature: 0.3,
        };

        // POST to the IONOS chat/completions endpoint
        const response = await axios.post(
          'https://openai.inference.de-txl.ionos.com/v1/chat/completions',
          body,
          {
            headers: {
              'Authorization': `Bearer ${apiKey}`,
              'Content-Type': 'application/json'
            }
          }
        );

        // Extract the assistant’s reply
        const reply = response.data.choices?.[0]?.message?.content;
        if (!reply) {
          throw new Error('No completion in IONOS response');
        }

        newMsg.payload = reply;
        node.send(newMsg);
        node.status({fill:"green", shape:"ring", text:"Done"});
      } catch (err) {
        node.status({fill:"red", shape:"dot", text:"Failed"});
        node.error("Error: " + err.message, msg);
      }
    });
  }
  RED.nodes.registerType("prompt-node", PromptResponse);
};